// Package sqlc provides a type-safe ORM library using generics and code generation.
// This file implements model relationship definitions and eager loading functionality.
//
// Relationships are one of the core features of ORM, allowing automatic loading of
// associated models when querying the main model. sqlc supports two main types:
//   - HasOne: One-to-one relationship (e.g., user has one profile)
//   - HasMany: One-to-many relationship (e.g., user has many posts)
//
// Relationship implementation:
//  1. Define Relation struct describing foreign key and local key mappings
//  2. Use Preload() function to create preload executor
//  3. Automatically execute associated queries after main query
//  4. Populate associated data into main model
//
// Usage example:
//
//	// Define User and Post models
//	type User struct {
//	    ID    int64   `db:"id,primaryKey"`
//	    Name  string  `db:"name"`
//	    Posts []*Post `db:"-"` // Relationship field, not mapped to database column
//	}
//
//	type Post struct {
//	    ID     int64  `db:"id,primaryKey"`
//	    UserID int64  `db:"user_id"` // Foreign key
//	    Title  string `db:"title"`
//	}
//
//	// Define relationship (usually generated by code generator)
//	userHasManyPosts := sqlc.HasMany[User, Post](
//	    clause.Column{Name: "user_id"},           // Foreign key (in posts table)
//	    clause.Column{Name: "id"},                // Local key (in users table)
//	    func(u *User, posts []*Post) { u.Posts = posts },
//	    func(u *User) any { return u.ID },
//	)
//
//	// Query with preload
//	users, err := userRepo.Query().
//	    WithPreload(sqlc.Preload(userHasManyPosts)).
//	    Find(ctx)
//	// users[0].Posts is automatically loaded
//
// Performance optimization:
//   - Uses IN query to batch load associated data, avoiding N+1 problem
//   - Supports nested preloading (preloaded associations can preload their associations)
//   - Automatically initializes empty slices to avoid nil pointers
package sqlc

import (
	"context"

	"github.com/arllen133/sqlc/clause"
)

// RelationType defines the type of relationship.
// Different relationship types differ in data loading and population methods.
type RelationType int

const (
	// RelationHasOne indicates a one-to-one relationship.
	// Parent model has one child model.
	//
	// Characteristics:
	//   - Foreign key is in child table
	//   - Each parent model has at most one associated child model
	//   - Setter receives slice with 0 or 1 element
	//
	// Examples:
	//   - User has one profile
	//   - Order has one shipping address
	//   - Article has one author info
	//
	// Database structure:
	//   users: id, name
	//   profiles: id, user_id (foreign key), bio
	//
	// Usage example:
	//
	//	userHasOneProfile := sqlc.HasOne[User, Profile](
	//	    clause.Column{Name: "user_id"},  // profiles.user_id
	//	    clause.Column{Name: "id"},       // users.id
	//	    func(u *User, p *Profile) { u.Profile = p },
	//	    func(u *User) any { return u.ID },
	//	)
	RelationHasOne RelationType = iota

	// RelationHasMany indicates a one-to-many relationship.
	// Parent model has many child models.
	//
	// Characteristics:
	//   - Foreign key is in child table
	//   - Each parent model can have multiple associated child models
	//   - Setter receives slice with any number of elements
	//   - Automatically initializes empty slice to avoid nil
	//
	// Examples:
	//   - User has many posts
	//   - Category has many products
	//   - Department has many employees
	//
	// Database structure:
	//   users: id, name
	//   posts: id, user_id (foreign key), title
	//
	// Usage example:
	//
	//	userHasManyPosts := sqlc.HasMany[User, Post](
	//	    clause.Column{Name: "user_id"},  // posts.user_id
	//	    clause.Column{Name: "id"},       // users.id
	//	    func(u *User, posts []*Post) { u.Posts = posts },
	//	    func(u *User) any { return u.ID },
	//	)
	RelationHasMany
)

// Relation defines a relationship between parent model P and child model C.
// This is the core definition of a relationship, containing all necessary
// information to load associated data.
//
// Type parameters:
//   - P: Parent model type (e.g., User)
//   - C: Child model type (e.g., Post)
//
// Key concepts:
//   - Foreign Key: Column in child table referencing parent table
//   - Local Key: Column in parent table being referenced (usually primary key)
//   - Setter: Function to set loaded child models into parent model
//   - GetLocalKeyValue: Function to extract local key value from parent model
//
// Usage example:
//
//	// User has many posts
//	relation := Relation[User, Post]{
//	    Type:       RelationHasMany,
//	    ForeignKey: clause.Column{Name: "user_id"},
//	    LocalKey:   clause.Column{Name: "id"},
//	    Setter:     func(u *User, posts []*Post) { u.Posts = posts },
//	    GetLocalKeyValue: func(u *User) any { return u.ID },
//	}
//
// Note:
//   - Usually created using HasOne() or HasMany() functions, not directly constructed
//   - Can be automatically generated by code generator
type Relation[P, C any] struct {
	// Type is the relationship type (HasOne or HasMany).
	// Affects data loading and population behavior.
	Type RelationType

	// ForeignKey is the foreign key column in child table.
	// Used to find associated records in child table.
	//
	// Examples:
	//   - For User has many Posts, foreign key is posts.user_id
	//   - For User has one Profile, foreign key is profiles.user_id
	ForeignKey clause.Column

	// LocalKey is the local key column in parent table.
	// Usually the primary key of parent table, used to match with foreign key.
	//
	// Examples:
	//   - For User has many Posts, local key is users.id
	//   - For User has one Profile, local key is users.id
	LocalKey clause.Column

	// Setter sets loaded child models into parent model.
	// This is the data population function.
	//
	// Parameters:
	//   - parent: Parent model instance pointer
	//   - children: Child model slice
	//
	// For HasOne:
	//   - children contains 0 or 1 element
	//   - If empty, indicates no associated record
	//
	// For HasMany:
	//   - children contains all associated records
	//   - If empty slice, indicates no associated record (already initialized)
	//
	// Examples:
	//   // HasOne
	//   func(u *User, children []*Profile) {
	//       if len(children) > 0 {
	//           u.Profile = children[0]
	//       }
	//   }
	//
	//   // HasMany
	//   func(u *User, posts []*Post) {
	//       u.Posts = posts
	//   }
	Setter func(parent *P, children []*C)

	// GetLocalKeyValue extracts local key value from parent model.
	// Used to build IN condition for associated queries.
	//
	// Parameters:
	//   - parent: Parent model instance pointer
	//
	// Returns:
	//   - any: Local key value (e.g., user ID)
	//
	// Example:
	//   func(u *User) any { return u.ID }
	GetLocalKeyValue func(parent *P) any
}

// HasOne creates a HasOne relationship definition.
// Used to define one-to-one relationships.
//
// Type parameters:
//   - P: Parent model type
//   - C: Child model type
//
// Parameters:
//   - foreignKey: Foreign key column in child table
//   - localKey: Local key column in parent table (usually primary key)
//   - setter: Setter function to set single child model into parent model
//   - getLocalKey: Extract function to get local key value from parent model
//
// Returns:
//   - Relation[P, C]: Relationship definition
//
// Usage example:
//
//	// User has one profile
//	userHasOneProfile := sqlc.HasOne[User, Profile](
//	    clause.Column{Name: "user_id"},  // profiles.user_id
//	    clause.Column{Name: "id"},       // users.id
//	    func(u *User, p *Profile) {
//	        if p != nil {
//	            u.Profile = p
//	        }
//	    },
//	    func(u *User) any { return u.ID },
//	)
//
//	// Use with preload
//	users, err := userRepo.Query().
//	    WithPreload(sqlc.Preload(userHasOneProfile)).
//	    Find(ctx)
func HasOne[P, C any](
	foreignKey clause.Column,
	localKey clause.Column,
	setter func(*P, *C),
	getLocalKey func(*P) any,
) Relation[P, C] {
	return Relation[P, C]{
		Type:       RelationHasOne,
		ForeignKey: foreignKey,
		LocalKey:   localKey,
		Setter: func(p *P, children []*C) {
			// HasOne relationship: only take first child model
			if len(children) > 0 {
				setter(p, children[0])
			}
		},
		GetLocalKeyValue: getLocalKey,
	}
}

// HasMany creates a HasMany relationship definition.
// Used to define one-to-many relationships.
//
// Type parameters:
//   - P: Parent model type
//   - C: Child model type
//
// Parameters:
//   - foreignKey: Foreign key column in child table
//   - localKey: Local key column in parent table (usually primary key)
//   - setter: Setter function to set child model slice into parent model
//   - getLocalKey: Extract function to get local key value from parent model
//
// Returns:
//   - Relation[P, C]: Relationship definition
//
// Usage example:
//
//	// User has many posts
//	userHasManyPosts := sqlc.HasMany[User, Post](
//	    clause.Column{Name: "user_id"},  // posts.user_id
//	    clause.Column{Name: "id"},       // users.id
//	    func(u *User, posts []*Post) {
//	        u.Posts = posts // Can be empty slice, but not nil
//	    },
//	    func(u *User) any { return u.ID },
//	)
//
//	// Use with preload
//	users, err := userRepo.Query().
//	    WithPreload(sqlc.Preload(userHasManyPosts)).
//	    Find(ctx)
//
// Note:
//   - Even if no associated records, empty slice is set (not nil)
//   - This avoids need for nil pointer checks
func HasMany[P, C any](
	foreignKey clause.Column,
	localKey clause.Column,
	setter func(*P, []*C),
	getLocalKey func(*P) any,
) Relation[P, C] {
	return Relation[P, C]{
		Type:             RelationHasMany,
		ForeignKey:       foreignKey,
		LocalKey:         localKey,
		Setter:           setter,
		GetLocalKeyValue: getLocalKey,
	}
}

// Preload creates a preload executor for given relationship.
// This is a standalone function returning a function to be added to QueryBuilder.
//
// Type parameters:
//   - P: Parent model type
//   - C: Child model type
//
// Parameters:
//   - rel: Relationship definition
//
// Returns:
//   - preloadExecutor[P]: Preload executor function
//
// Preload flow:
//  1. Collect local key values from all parent models
//  2. Build IN query to batch load all associated child models
//  3. Group child models by foreign key value
//  4. Iterate parent models and set corresponding child models
//  5. For HasMany, initialize empty slices
//
// Performance advantages:
//   - Avoids N+1 query problem
//   - Uses single IN query to load all associated data
//   - Performs data matching in memory, highly efficient
//
// Usage example:
//
//	// Single preload
//	users, err := userRepo.Query().
//	    WithPreload(sqlc.Preload(userHasManyPosts)).
//	    Find(ctx)
//
//	// Multiple preloads
//	users, err := userRepo.Query().
//	    WithPreload(sqlc.Preload(userHasManyPosts)).
//	    WithPreload(sqlc.Preload(userHasOneProfile)).
//	    Find(ctx)
//
//	// Nested preload (posts' comments)
//	users, err := userRepo.Query().
//	    WithPreload(sqlc.Preload(userHasManyPosts)).
//	    WithPreload(sqlc.Preload(postHasManyComments)).
//	    Find(ctx)
func Preload[P, C any](rel Relation[P, C]) preloadExecutor[P] {
	return func(ctx context.Context, session *Session, parents []*P) error {
		// Fast return: no parent models, no need to load
		if len(parents) == 0 {
			return nil
		}

		// Step 1: Collect local key values from all parent models
		// These values are used to build IN query condition
		parentIDs := make([]any, 0, len(parents))
		// parentMap maps local key values to parent models
		// Uses int64 as key, need to normalize various numeric types first
		parentMap := make(map[int64][]*P)
		for _, p := range parents {
			id := rel.GetLocalKeyValue(p)
			parentIDs = append(parentIDs, id)
			normalizedID := normalizeToInt64(id)
			parentMap[normalizedID] = append(parentMap[normalizedID], p)
		}

		// Step 2: Build and execute IN query
		// Query all child models whose foreign key is in parent ID list
		childSchema := LoadSchema[C]()
		query := Query[C](session).Where(clause.IN{
			Column: rel.ForeignKey,
			Values: parentIDs,
		})

		// Execute query to get all associated child models
		children, err := query.Find(ctx)
		if err != nil {
			return err
		}

		// Step 3: Group child models by foreign key value
		// Build mapping: foreign key value -> child model list
		childMap := make(map[int64][]*C)
		for _, child := range children {
			// Extract foreign key value from child model
			fkValue := getFieldValue(child, rel.ForeignKey.Name)
			normalizedFK := normalizeToInt64(fkValue)
			childMap[normalizedFK] = append(childMap[normalizedFK], child)
		}

		// Step 4: Set child models into corresponding parent models
		for _, p := range parents {
			id := rel.GetLocalKeyValue(p)
			normalizedID := normalizeToInt64(id)
			// Get all child models for this parent model
			rel.Setter(p, childMap[normalizedID])
		}

		// Step 5: For HasMany, initialize empty slices
		// Ensure parent models without associated records also have empty slices (not nil)
		if rel.Type == RelationHasMany {
			for _, p := range parents {
				id := rel.GetLocalKeyValue(p)
				normalizedID := normalizeToInt64(id)
				if _, ok := childMap[normalizedID]; !ok {
					// No associated records, set empty slice
					rel.Setter(p, []*C{})
				}
			}
		}

		// Ensure childSchema is used (avoid compiler warning)
		_ = childSchema
		return nil
	}
}

// normalizeToInt64 converts common numeric types to int64.
// Used as map key for consistent comparison.
//
// Supported types:
//   - int, int8, int16, int32, int64
//   - uint, uint8, uint16, uint32, uint64
//   - float32, float64 (truncates decimal part)
//
// Parameters:
//   - v: Value of any type
//
// Returns:
//   - int64: Normalized value, returns 0 for unsupported types
//
// Usage scenarios:
//   - Convert different types of IDs to unified type for map keys
//   - Handle different integer types returned by database drivers
//
// Note:
//   - Returns 0 for unsupported types
//   - Large values (exceeding int64 range) will overflow
//   - Float types lose precision
func normalizeToInt64(v any) int64 {
	switch val := v.(type) {
	case int:
		return int64(val)
	case int8:
		return int64(val)
	case int16:
		return int64(val)
	case int32:
		return int64(val)
	case int64:
		return val
	case uint:
		return int64(val)
	case uint8:
		return int64(val)
	case uint16:
		return int64(val)
	case uint32:
		return int64(val)
	case uint64:
		return int64(val)
	case float32:
		return int64(val)
	case float64:
		return int64(val)
	default:
		// Unsupported type returns 0
		// This may cause data matching failure but avoids panic
		return 0
	}
}
