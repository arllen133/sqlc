// Package sqlc provides a type-safe ORM library using generics and code generation.
// This file implements model relationship definitions and eager loading functionality.
//
// Relationships are one of the core features of ORM, allowing automatic loading of
// associated models when querying the main model. sqlc supports two main types:
//   - HasOne: One-to-one relationship (e.g., user has one profile)
//   - HasMany: One-to-many relationship (e.g., user has many posts)
//
// Relationship implementation:
//  1. Define Relation struct describing foreign key and local key mappings
//  2. Use Preload() function to create preload executor
//  3. Automatically execute associated queries after main query
//  4. Populate associated data into main model
//
// Usage example:
//
//	// Define relationship (usually generated by code generator)
//	userHasManyPosts := sqlc.HasMany[User, Post, int64](
//	    clause.Column{Name: "user_id"},
//	    clause.Column{Name: "id"},
//	    func(u *User, posts []*Post) { u.Posts = posts },
//	    func(u *User) int64 { return u.ID },
//	    func(p *Post) int64 { return p.UserID },
//	)
//
//	// Query with preload
//	users, err := userRepo.Query().
//	    WithPreload(sqlc.Preload(userHasManyPosts)).
//	    Find(ctx)
//
// Performance optimization:
//   - Uses IN query to batch load associated data, avoiding N+1 problem
//   - Uses native typed map keys instead of fmt.Sprint for zero-overhead grouping
//   - Deduplicates IN values to minimize query size
//   - Supports child query customization via options
package sqlc

import (
	"context"

	"github.com/arllen133/sqlc/clause"
)

// RelationType defines the type of relationship.
type RelationType int

const (
	// RelationHasOne indicates a one-to-one relationship.
	// Parent model has one child model.
	RelationHasOne RelationType = iota

	// RelationHasMany indicates a one-to-many relationship.
	// Parent model has many child models.
	RelationHasMany
)

// Relation defines a relationship between parent model P and child model C,
// using key type K for type-safe grouping without fmt.Sprint overhead.
//
// Type parameters:
//   - P: Parent model type (e.g., User)
//   - C: Child model type (e.g., Post)
//   - K: Key type for matching (must be comparable, e.g., int64, string)
type Relation[P, C any, K comparable] struct {
	// Type is the relationship type (HasOne or HasMany).
	Type RelationType

	// ForeignKey is the foreign key column in child table.
	ForeignKey clause.Column

	// LocalKey is the local key column in parent table.
	LocalKey clause.Column

	// Setter sets loaded child models into parent model.
	Setter func(parent *P, children []*C)

	// GetLocalKeyValue extracts typed local key value from parent model.
	GetLocalKeyValue func(parent *P) K

	// GetForeignKeyValue extracts typed foreign key value from child model.
	GetForeignKeyValue func(child *C) K
}

// HasOne creates a HasOne relationship definition.
//
// Type parameters:
//   - P: Parent model type
//   - C: Child model type
//   - K: Key type (e.g., int64, string)
//
// Example:
//
//	userHasOneProfile := sqlc.HasOne[User, Profile, int64](
//	    clause.Column{Name: "user_id"},
//	    clause.Column{Name: "id"},
//	    func(u *User, p *Profile) { u.Profile = p },
//	    func(u *User) int64 { return u.ID },
//	    func(p *Profile) int64 { return p.UserID },
//	)
func HasOne[P, C any, K comparable](
	foreignKey clause.Column,
	localKey clause.Column,
	setter func(*P, *C),
	getLocalKey func(*P) K,
	getForeignKey func(*C) K,
) Relation[P, C, K] {
	return Relation[P, C, K]{
		Type:       RelationHasOne,
		ForeignKey: foreignKey,
		LocalKey:   localKey,
		Setter: func(p *P, children []*C) {
			if len(children) > 0 {
				setter(p, children[0])
			}
		},
		GetLocalKeyValue:   getLocalKey,
		GetForeignKeyValue: getForeignKey,
	}
}

// HasMany creates a HasMany relationship definition.
//
// Type parameters:
//   - P: Parent model type
//   - C: Child model type
//   - K: Key type (e.g., int64, string)
//
// Example:
//
//	userHasManyPosts := sqlc.HasMany[User, Post, int64](
//	    clause.Column{Name: "user_id"},
//	    clause.Column{Name: "id"},
//	    func(u *User, posts []*Post) { u.Posts = posts },
//	    func(u *User) int64 { return u.ID },
//	    func(p *Post) int64 { return p.UserID },
//	)
func HasMany[P, C any, K comparable](
	foreignKey clause.Column,
	localKey clause.Column,
	setter func(*P, []*C),
	getLocalKey func(*P) K,
	getForeignKey func(*C) K,
) Relation[P, C, K] {
	return Relation[P, C, K]{
		Type:       RelationHasMany,
		ForeignKey: foreignKey,
		LocalKey:   localKey,
		Setter: func(p *P, children []*C) {
			if len(children) == 0 {
				children = []*C{}
			}
			setter(p, children)
		},
		GetLocalKeyValue:   getLocalKey,
		GetForeignKeyValue: getForeignKey,
	}
}

// Preload creates a preload executor for given relationship.
// Supports optional child query customization via variadic options.
//
// Features:
//   - Uses typed map[K] for zero-overhead key grouping (no fmt.Sprint)
//   - Deduplicates IN values to minimize query size
//   - Supports child query customization (WHERE, ORDER BY, LIMIT, etc.)
//
// Example:
//
//	// Basic preload
//	sqlc.Preload(userHasManyPosts)
//
//	// Preload with conditions
//	sqlc.Preload(userHasManyPosts, func(q *sqlc.QueryBuilder[Post]) *sqlc.QueryBuilder[Post] {
//	    return q.Where(generated.Post.Status.Eq("published")).
//	            OrderBy(generated.Post.CreatedAt.Desc()).
//	            Limit(10)
//	})
func Preload[P, C any, K comparable](
	rel Relation[P, C, K],
	opts ...func(*QueryBuilder[C]) *QueryBuilder[C],
) preloadExecutor[P] {
	return func(ctx context.Context, session *Session, parents []*P) error {
		if len(parents) == 0 {
			return nil
		}

		// Step 1: Collect and deduplicate local key values
		seen := make(map[K]struct{}, len(parents))
		foreignKeys := make([]any, 0, len(parents))
		for i := range parents {
			k := rel.GetLocalKeyValue(parents[i])
			if _, ok := seen[k]; !ok {
				seen[k] = struct{}{}
				foreignKeys = append(foreignKeys, k)
			}
		}

		// Fast return: all keys deduplicated to empty (e.g., all zero values filtered)
		if len(foreignKeys) == 0 {
			return nil
		}

		// Step 2: Build query with optimal expression
		query := Query[C](session)
		if len(foreignKeys) == 1 {
			query = query.Where(clause.Eq{
				Column: rel.ForeignKey,
				Value:  foreignKeys[0],
			})
		} else {
			query = query.Where(clause.IN{
				Column: rel.ForeignKey,
				Values: foreignKeys,
			})
		}

		// Apply user-provided query customizations
		for _, opt := range opts {
			query = opt(query)
		}

		children, err := query.Find(ctx)
		if err != nil {
			return err
		}

		// Step 3: Group child models by foreign key using typed map (no fmt.Sprint)
		childMap := make(map[K][]*C)
		for _, child := range children {
			fk := rel.GetForeignKeyValue(child)
			childMap[fk] = append(childMap[fk], child)
		}

		// Step 4: Set child models into corresponding parent models
		for _, p := range parents {
			k := rel.GetLocalKeyValue(p)
			rel.Setter(p, childMap[k])
		}

		return nil
	}
}
