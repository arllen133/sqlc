package generator

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"runtime/debug"
	"strings"
	"text/template"
)

var Version = "dev"

// init attempts to read the version from build info if it wasn't injected via ldflags.
func init() {
	if Version == "dev" {
		if info, ok := debug.ReadBuildInfo(); ok {
			if info.Main.Version != "" && info.Main.Version != "(devel)" {
				Version = info.Main.Version
			}
		}
	}
}

const schemaTemplate = `// Code generated by sqlcli. DO NOT EDIT.
// Version: {{.CliVersion}}

package {{.PackageName}}
{{if not .IsJSONOnly}}
import (
	"github.com/arllen133/sqlc"
	"github.com/arllen133/sqlc/clause"
	"github.com/arllen133/sqlc/field"
	{{if .HasJSONField}}json "github.com/arllen133/sqlc/field/json"{{end}}
	{{if .ModulePath}}{{if .PackagePath}}"{{.ModulePath}}/{{.PackagePath}}"{{else}}"{{.ModulePath}}"{{end}}{{end}}
	{{if .HasJSON}}"encoding/json"{{end}}
	{{if .SoftDeleteField}}"time"{{end}}
	{{if eq .SoftDeleteFieldType "sql.NullTime"}}"database/sql"{{end}}
)

func init(){
	sqlc.RegisterSchema(&{{.ModelName}})
}

// {{.ModelName}} Schema:
{{- range .Doc}}
// {{.}}
{{- end}}
type {{.SchemaStructName}} struct {
	{{- range .Fields}}
	{{- if .Doc}}
	// {{.FieldName}}: {{range .Doc}}{{.}}{{end}}
	{{- end}}
	{{- if .IsJSON}}
	{{.FieldName}} field.JSON[{{$.ParentPackage}}.{{.JSONTypeName}}]
	{{- else}}
	{{.FieldName}} {{$.GetFieldType .Type}}
	{{- end}}
	{{- end}}
}

var _ sqlc.Schema[{{.ParentPackage}}.{{.ModelName}}] = (*{{.SchemaStructName}})(nil)

var {{.ModelName}} = {{.SchemaStructName}}{
	{{- range .Fields}}
	{{- if .IsJSON}}
	{{.FieldName}}: field.JSON[{{$.ParentPackage}}.{{.JSONTypeName}}]{}.WithColumn("{{.Column}}"),
	{{- else}}
	{{.FieldName}}: {{$.GetFieldType .Type}}{}.WithColumn("{{.Column}}"),
	{{- end}}
	{{- end}}
}

func (s *{{.SchemaStructName}}) TableName() string {
	return "{{.TableName}}"
}

func (s *{{.SchemaStructName}}) SelectColumns() []string {
	return []string{
		{{- range .Fields}}
		"{{.Column}}",
		{{- end}}
	}
}

func (s *{{.SchemaStructName}}) InsertRow(m *{{.ParentPackage}}.{{.ModelName}}) ([]string, []any) {
	var cols []string
	var vals []any
	{{- range .Fields}}
	{{- if .IsPK}}
	{{- if $.IsAutoIncrementPK}}
	// AutoIncrement PK: include only if explicitly set (non-zero)
	if m.{{.FieldName}} != 0 {
		cols = append(cols, "{{.Column}}")
		vals = append(vals, m.{{.FieldName}})
	}
	{{- else}}
	// Non-AutoIncrement PK: always include
	cols = append(cols, "{{.Column}}")
	vals = append(vals, m.{{.FieldName}})
	{{- end}}
	{{- else}}
	cols = append(cols, "{{.Column}}")
	vals = append(vals, m.{{.FieldName}})
	{{- end}}
	{{- end}}
	return cols, vals
}

func (s *{{.SchemaStructName}}) UpdateMap(m *{{.ParentPackage}}.{{.ModelName}}) map[string]any {
	res := make(map[string]any)
	{{- range .Fields}}
	{{- if not .IsPK}}
	res["{{.Column}}"] = m.{{.FieldName}}
	{{- end}}
	{{- end}}
	return res
}

func (s *{{.SchemaStructName}}) PK(m *{{.ParentPackage}}.{{.ModelName}}) sqlc.PK {
	{{- if .PKFieldName}}
	var val any
	if m != nil {
		val = m.{{.PKFieldName}}
	}
	return sqlc.PK{
		Column: clause.Column{Name: "{{.PKColumnName}}"},
		Value:  val,
	}
	{{- else}}
	return sqlc.PK{}
	{{- end}}
}

func (s *{{.SchemaStructName}}) SetPK(m *{{.ParentPackage}}.{{.ModelName}}, val int64) {
	{{- if .PKFieldName}}
	{{- if eq .PKFieldType "int64"}}
	m.{{.PKFieldName}} = val
	{{- else if $.IsNumeric .PKFieldType}}
	m.{{.PKFieldName}} = {{$.QualifyPKType}}(val)
	{{- end}}
	{{- end}}
}

func (s *{{.SchemaStructName}}) AutoIncrement() bool {
	return {{.IsAutoIncrementPK}}
}

func (s *{{.SchemaStructName}}) SoftDeleteColumn() string {
	{{if .SoftDeleteField -}}
	return "{{.SoftDeleteColumn}}"
	{{- else -}}
	return ""
	{{- end}}
}

func (s *{{.SchemaStructName}}) SoftDeleteValue() any {
	{{- if .SoftDeleteField}}
	{{- if or (eq .SoftDeleteFieldType "*time.Time") (eq .SoftDeleteFieldType "time.Time") (eq .SoftDeleteFieldType "sql.NullTime")}}
	return time.Now()
	{{- else if or (eq .SoftDeleteFieldType "int64") (eq .SoftDeleteFieldType "uint64")}}
	return time.Now().Unix()
	{{- else if or (eq .SoftDeleteFieldType "int32") (eq .SoftDeleteFieldType "uint32")}}
	return int32(time.Now().Unix())
	{{- else}}
	return time.Now() // Default fallback
	{{- end}}
	{{- else}}
	return nil
	{{- end}}
}

func (s *{{.SchemaStructName}}) SetDeletedAt(m *{{.ParentPackage}}.{{.ModelName}}) {
	{{- if .SoftDeleteField}}
	{{- if eq .SoftDeleteFieldType "sql.NullTime"}}
	m.{{.SoftDeleteField}} = sql.NullTime{Time: time.Now(), Valid: true}
	{{- else if or (eq .SoftDeleteFieldType "int64") (eq .SoftDeleteFieldType "uint64")}}
	m.{{.SoftDeleteField}} = time.Now().Unix()
	{{- else if or (eq .SoftDeleteFieldType "int32") (eq .SoftDeleteFieldType "uint32")}}
	m.{{.SoftDeleteField}} = int32(time.Now().Unix())
	{{- else if hasPrefix .SoftDeleteFieldType "*"}}
	now := time.Now()
	m.{{.SoftDeleteField}} = &now
	{{- else}}
	m.{{.SoftDeleteField}} = time.Now()
	{{- end}}
	{{- end}}
}
{{end}}
{{- range .JSONFields}}
{{- $col := .ColumnName}}
// {{.TypeName}} is a type-safe JSON path accessor for the {{$col}} column
var {{.TypeName}} = struct {
	{{- range .Paths}}
	{{.GoName}} json.JSONPath
	{{- end}}
}{
	{{- range .Paths}}
	{{.GoName}}: json.JSONPath{Column: "{{$col}}", Path: "{{.JSONPath}}"},
	{{- end}}
}
{{end}}
{{- range .Relations}}
// {{$.ModelName}}_{{.FieldName}} defines {{.RelType}} relation: {{$.ModelName}} has {{if eq .RelType "hasMany"}}many{{else}}one{{end}} {{.TargetType}}
var {{$.ModelName}}_{{.FieldName}} = sqlc.{{if eq .RelType "hasMany"}}HasMany{{else}}HasOne{{end}}(
	{{if eq .RelType "belongsTo"}}clause.Column{Name: "{{.LocalKey}}"},
	clause.Column{Name: "{{.ForeignKey}}"},
	func(p *{{$.ParentPackage}}.{{$.ModelName}}, child *{{$.ParentPackage}}.{{.TargetType}}) { p.{{.FieldName}} = child },
	func(p *{{$.ParentPackage}}.{{$.ModelName}}) {{$.PKFieldType}} { return p.{{.ForeignKeyField}} },
	func(c *{{$.ParentPackage}}.{{.TargetType}}) {{$.PKFieldType}} { return c.{{.TargetPKField}} },
	{{else}}clause.Column{Name: "{{.ForeignKey}}"},
	clause.Column{Name: "{{.LocalKey}}"},
	{{if eq .RelType "hasMany"}}func(p *{{$.ParentPackage}}.{{$.ModelName}}, children []*{{$.ParentPackage}}.{{.TargetType}}) { p.{{.FieldName}} = children },
	{{else}}func(p *{{$.ParentPackage}}.{{$.ModelName}}, child *{{$.ParentPackage}}.{{.TargetType}}) { p.{{.FieldName}} = child },
	{{end}}func(p *{{$.ParentPackage}}.{{$.ModelName}}) {{$.PKFieldType}} { return p.{{$.PKFieldName}} },
	func(c *{{$.ParentPackage}}.{{.TargetType}}) {{$.PKFieldType}} { return {{if .ForeignKeyFieldType}}{{.ForeignKeyFieldType}}(c.{{.ForeignKeyField}}){{else}}c.{{.ForeignKeyField}}{{end}} },
	{{end}}
)
{{end}}
`

// GenerateFile creates a *_gen.go file for a model.
// Filenames are generated using snake_case (e.g. UserConfig -> user_config_gen.go).
func GenerateFile(meta ModelMeta, outDir string) error {
	// Skip file generation for JSON-only structs (they're generated as paths in their parent)
	if meta.IsJSONOnly {
		return nil
	}

	// Populate dynamic fields
	meta.CliVersion = Version

	for _, f := range meta.Fields {
		if strings.Contains(meta.GetFieldType(f.Type), "field.JSON") {
			meta.HasJSON = true
		}
		// Parse JSON field paths if type:json is set
		if f.IsJSON && f.JSONTypeName != "" {
			meta.HasJSONField = true
			paths := parseJSONStructPaths(outDir, f.JSONTypeName, "")
			if len(paths) > 0 {
				meta.JSONFields = append(meta.JSONFields, JSONFieldMeta{
					FieldName:  f.FieldName,
					TypeName:   f.JSONTypeName,
					ColumnName: f.Column,
					Paths:      paths,
				})
			}
		}
	}

	funcMap := template.FuncMap{
		"hasPrefix": strings.HasPrefix,
	}

	tmpl, err := template.New("schema").Funcs(funcMap).Parse(schemaTemplate)
	if err != nil {
		return err
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, meta); err != nil {
		return err
	}

	// Format the generated code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return fmt.Errorf("failed to format source: %w", err)
	}

	// Create generated subdirectory
	generatedDir := filepath.Join(outDir, "generated")
	if err := os.MkdirAll(generatedDir, 0755); err != nil {
		return err
	}

	filename := filepath.Join(generatedDir, toSnakeCase(meta.ModelName)+"_gen.go")
	return os.WriteFile(filename, formatted, 0644)
}

// GetFieldType returns the appropriate field type based on Go type
func (m ModelMeta) GetFieldType(goType string) string {
	// 1. Check user-defined mapping first (from config.go)
	if m.FieldTypeMap != nil {
		if fieldType, ok := m.FieldTypeMap[goType]; ok {
			return fieldType
		}
	}

	// 2. Resolve type aliases (type A int â†’ int)
	resolvedType := goType
	isAlias := false
	if m.TypeAliases != nil {
		if underlying, ok := m.TypeAliases[goType]; ok {
			resolvedType = underlying
			isAlias = true
		}
	}

	// 3. For numeric aliases, use the alias type in generic (field.Number[Alias])
	if isAlias {
		// Qualify type if it's from current package
		typeName := goType
		if !strings.Contains(goType, ".") && m.ParentPackage != "" {
			typeName = m.ParentPackage + "." + goType
		}

		if m.IsNumeric(resolvedType) {
			return fmt.Sprintf("field.Number[%s]", typeName)
		}

		// For non-numeric aliases (e.g. String alias), use generic Field[T]
		// This supports custom types without dedicated field implementation
		return fmt.Sprintf("field.Field[%s]", typeName)
	}

	// 4. Map to field types
	fieldType := m.mapToFieldType(resolvedType)

	// 5. If mapToFieldType returns basic "field.Field[any]", upgrade to generic "field.Field[T]" if possible
	if fieldType == "field.Field[any]" {
		// Check if it's a struct or something we can use generic Field for?
		// For now, let's assume unknown types are better off as field.Field[Type] if they are not standard.
		// But mapToFieldType has default case.

		// If goType is simply "MyStruct", we want "field.Field[MyStruct]" (qualified).
		if !m.isBuiltin(goType) {
			typeName := goType
			if !strings.Contains(goType, ".") && m.ParentPackage != "" {
				typeName = m.ParentPackage + "." + goType
			}
			return fmt.Sprintf("field.Field[%s]", typeName)
		}
	}

	return fieldType
}

func (m ModelMeta) isBuiltin(typ string) bool {
	switch typ {
	case "string", "int", "int64", "float64", "bool", "byte", "rune", "any", "complex64", "complex128", "error":
		return true
	}
	return false
}

// mapToFieldType converts a Go type to its corresponding field type
func (m ModelMeta) mapToFieldType(goType string) string {
	switch goType {
	case "string":
		return "field.String"
	case "int":
		return "field.Number[int]"
	case "int8":
		return "field.Number[int8]"
	case "int16":
		return "field.Number[int16]"
	case "int32":
		return "field.Number[int32]"
	case "int64":
		return "field.Number[int64]"
	case "uint":
		return "field.Number[uint]"
	case "uint8":
		return "field.Number[uint8]"
	case "uint16":
		return "field.Number[uint16]"
	case "uint32":
		return "field.Number[uint32]"
	case "uint64":
		return "field.Number[uint64]"
	case "float32":
		return "field.Number[float32]"
	case "float64":
		return "field.Number[float64]"
	case "bool":
		return "field.Bool"
	case "time.Time", "*time.Time":
		return "field.Time"
	case "[]byte":
		return "field.Bytes"
	case "json.RawMessage":
		return "field.JSON[json.RawMessage]"
	default:
		return "field.Field[any]"
	}
}

// IsNumeric checks if the Go type is numeric
func (m ModelMeta) IsNumeric(goType string) bool {
	switch goType {
	case "int", "int8", "int16", "int32", "int64",
		"uint", "uint8", "uint16", "uint32", "uint64",
		"float32", "float64":
		return true
	default:
		// Check aliases
		if m.TypeAliases != nil {
			if underlying, ok := m.TypeAliases[goType]; ok {
				return m.IsNumeric(underlying)
			}
		}
		return false
	}
}

// QualifyPKType returns the qualified type name for the PK field
func (m ModelMeta) QualifyPKType() string {
	typ := m.PKFieldType
	// If it's a built-in numeric type, no qualification needed.
	switch typ {
	case "int", "int8", "int16", "int32", "int64",
		"uint", "uint8", "uint16", "uint32", "uint64",
		"float32", "float64":
		return typ
	}
	// If it's an alias, qualify it.
	if !strings.Contains(typ, ".") && m.ParentPackage != "" {
		return m.ParentPackage + "." + typ
	}
	return typ
}

// GoIsNonZero returns the Go expression to check if a field is NOT zero value
func (m ModelMeta) GoIsNonZero(fieldName, goType string) string {
	if strings.HasPrefix(goType, "*") || strings.HasPrefix(goType, "[]") || strings.HasPrefix(goType, "map") {
		return "m." + fieldName + " != nil"
	}
	switch goType {
	case "string":
		return "m." + fieldName + " != \"\""
	case "int", "int8", "int16", "int32", "int64",
		"uint", "uint8", "uint16", "uint32", "uint64",
		"float32", "float64":
		return "m." + fieldName + " != 0"
	case "bool":
		return "m." + fieldName // bool zero is false, so non-zero is true
	case "time.Time":
		return "!m." + fieldName + ".IsZero()"
	case "json.RawMessage":
		return "len(m." + fieldName + ") > 0"
	default:
		// Slices, structs etc.
		if strings.HasPrefix(goType, "[]") {
			return "len(m." + fieldName + ") > 0"
		}
		// For structs, use strict IsZero check inverted
		return fmt.Sprintf("!reflect.ValueOf(m.%s).IsZero()", fieldName)
	}
}

const relationsTemplate = `// Code generated by sqlcli. DO NOT EDIT.
// Version: {{.CliVersion}}

package {{.PackageName}}

import (
	"github.com/arllen133/sqlc"
	"github.com/arllen133/sqlc/clause"
	{{if .ModulePath}}{{if .PackagePath}}"{{.ModulePath}}/{{.PackagePath}}"{{else}}"{{.ModulePath}}"{{end}}{{end}}
)

{{range .Relations}}
// {{$.ModelName}}_{{.FieldName}} defines {{.RelType}} relation: {{$.ModelName}} has {{if eq .RelType "hasMany"}}many{{else}}one{{end}} {{.TargetType}}
var {{$.ModelName}}_{{.FieldName}} = sqlc.{{if eq .RelType "hasMany"}}HasMany{{else}}HasOne{{end}}(
	clause.Column{Name: "{{.ForeignKey}}"},
	clause.Column{Name: "{{.LocalKey}}"},
	{{if eq .RelType "hasMany"}}func(p *{{$.ParentPackage}}.{{$.ModelName}}, children []*{{$.ParentPackage}}.{{.TargetType}}) { p.{{.FieldName}} = children },
	{{else}}func(p *{{$.ParentPackage}}.{{$.ModelName}}, child *{{$.ParentPackage}}.{{.TargetType}}) { p.{{.FieldName}} = child },
	{{end}}func(p *{{$.ParentPackage}}.{{$.ModelName}}) {{$.PKFieldType}} { return p.{{$.PKFieldName}} },
	func(c *{{$.ParentPackage}}.{{.TargetType}}) {{$.PKFieldType}} { return {{if .ForeignKeyFieldType}}{{.ForeignKeyFieldType}}(c.{{.ForeignKeyField}}){{else}}c.{{.ForeignKeyField}}{{end}} },
)
{{end}}
`

// RelationsData holds data for generating relations file
type RelationsData struct {
	PackageName   string
	ParentPackage string
	ModulePath    string
	PackagePath   string
	CliVersion    string
	ModelName     string
	PKFieldName   string
	PKFieldType   string
	Relations     []RelationMeta
}

// GenerateRelationsFile generates relations_gen.go with all relation definitions
func GenerateRelationsFile(models []ModelMeta, outDir string) error {
	// Collect all relations from all models
	var allRelations []RelationsData

	for _, model := range models {
		if len(model.Relations) == 0 {
			continue
		}

		data := RelationsData{
			PackageName:   model.PackageName,
			ParentPackage: model.ParentPackage,
			ModulePath:    model.ModulePath,
			PackagePath:   model.PackagePath,
			CliVersion:    Version,
			ModelName:     model.ModelName,
			PKFieldName:   model.PKFieldName,
			PKFieldType:   model.PKFieldType,
			Relations:     model.Relations,
		}
		allRelations = append(allRelations, data)
	}

	if len(allRelations) == 0 {
		return nil // No relations to generate
	}

	// Generate file for each model with relations
	for _, data := range allRelations {
		tmpl, err := template.New("relations").Parse(relationsTemplate)
		if err != nil {
			return err
		}

		var buf bytes.Buffer
		if err := tmpl.Execute(&buf, data); err != nil {
			return err
		}

		// Format the generated code
		formatted, err := format.Source(buf.Bytes())
		if err != nil {
			return fmt.Errorf("failed to format source: %w", err)
		}

		generatedDir := filepath.Join(outDir, "generated")
		if err := os.MkdirAll(generatedDir, 0755); err != nil {
			return err
		}

		filename := filepath.Join(generatedDir, toSnakeCase(data.ModelName)+"_relations_gen.go")
		if err := os.WriteFile(filename, formatted, 0644); err != nil {
			return err
		}
	}

	return nil
}
