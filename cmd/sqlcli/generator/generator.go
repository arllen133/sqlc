package generator

import (
	"bytes"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"text/template"
	"time"
)

const schemaTemplate = `// Code generated by sqlcli. DO NOT EDIT.
// Generated at: {{.GeneratedAt}}

package {{.PackageName}}
{{if not .IsJSONOnly}}
import (
	"github.com/arllen133/sqlc"
	"github.com/arllen133/sqlc/clause"
	"github.com/arllen133/sqlc/field"
	{{if .HasJSONField}}json "github.com/arllen133/sqlc/field/json"{{end}}
	{{if .ModulePath}}{{if .PackagePath}}"{{.ModulePath}}/{{.PackagePath}}"{{else}}"{{.ModulePath}}"{{end}}{{end}}
	{{if .HasJSON}}"encoding/json"{{end}}
)

// {{.ModelName}} Schema:
{{- range .Doc}}
// {{.}}
{{- end}}
type {{.SchemaStructName}} struct {
	{{- range .Fields}}
	{{- if .Doc}}
	// {{.FieldName}}: {{range .Doc}}{{.}}{{end}}
	{{- end}}
	{{- if .IsJSON}}
	{{.FieldName}} field.JSON[{{$.ParentPackage}}.{{.JSONTypeName}}]
	{{- else}}
	{{.FieldName}} {{$.GetFieldType .Type}}
	{{- end}}
	{{- end}}
}

var _ sqlc.Schema[{{.ParentPackage}}.{{.ModelName}}] = (*{{.SchemaStructName}})(nil)

var {{.ModelName}} = {{.SchemaStructName}}{
	{{- range .Fields}}
	{{- if .IsJSON}}
	{{.FieldName}}: field.JSON[{{$.ParentPackage}}.{{.JSONTypeName}}]{}.WithColumn("{{.Column}}"),
	{{- else}}
	{{.FieldName}}: {{$.GetFieldType .Type}}{}.WithColumn("{{.Column}}"),
	{{- end}}
	{{- end}}
}

func (s *{{.SchemaStructName}}) TableName() string {
	return "{{.TableName}}"
}

func (s *{{.SchemaStructName}}) SelectColumns() []string {
	return []string{
		{{- range .Fields}}
		"{{.Column}}",
		{{- end}}
	}
}

func (s *{{.SchemaStructName}}) InsertRow(m *{{.ParentPackage}}.{{.ModelName}}) ([]string, []any) {
	var cols []string
	var vals []any
	{{- range .Fields}}
	{{- if .IsPK}}
	{{- if $.IsAutoIncrementPK}}
	// AutoIncrement PK: include only if explicitly set (non-zero)
	if m.{{.FieldName}} != 0 {
		cols = append(cols, "{{.Column}}")
		vals = append(vals, m.{{.FieldName}})
	}
	{{- else}}
	// Non-AutoIncrement PK: always include
	cols = append(cols, "{{.Column}}")
	vals = append(vals, m.{{.FieldName}})
	{{- end}}
	{{- else}}
	cols = append(cols, "{{.Column}}")
	vals = append(vals, m.{{.FieldName}})
	{{- end}}
	{{- end}}
	return cols, vals
}

func (s *{{.SchemaStructName}}) UpdateMap(m *{{.ParentPackage}}.{{.ModelName}}) map[string]any {
	res := make(map[string]any)
	{{- range .Fields}}
	{{- if not .IsPK}}
	res["{{.Column}}"] = m.{{.FieldName}}
	{{- end}}
	{{- end}}
	return res
}

func (s *{{.SchemaStructName}}) PK(m *{{.ParentPackage}}.{{.ModelName}}) sqlc.PK {
	{{- if .PKFieldName}}
	var val any
	if m != nil {
		val = m.{{.PKFieldName}}
	}
	return sqlc.PK{
		Column: clause.Column{Name: "{{.PKColumnName}}"},
		Value:  val,
	}
	{{- else}}
	return sqlc.PK{}
	{{- end}}
}

func (s *{{.SchemaStructName}}) SetPK(m *{{.ParentPackage}}.{{.ModelName}}, val int64) {
	{{- if .PKFieldName}}
	{{- if eq .PKFieldType "int64"}}
	m.{{.PKFieldName}} = val
	{{- else if $.IsNumeric .PKFieldType}}
	m.{{.PKFieldName}} = {{$.QualifyPKType}}(val)
	{{- end}}
	{{- end}}
}

func (s *{{.SchemaStructName}}) AutoIncrement() bool {
	return {{.IsAutoIncrementPK}}
}

func init(){
	sqlc.RegisterSchema(&{{.ModelName}})
}
{{end}}
{{- range .JSONFields}}
{{- $col := .ColumnName}}
// {{.TypeName}} is a type-safe JSON path accessor for the {{$col}} column
var {{.TypeName}} = struct {
	{{- range .Paths}}
	{{.GoName}} json.JSONPath
	{{- end}}
}{
	{{- range .Paths}}
	{{.GoName}}: json.JSONPath{Column: "{{$col}}", Path: "{{.JSONPath}}"},
	{{- end}}
}
{{end}}
`

func GenerateFile(meta ModelMeta, outDir string) error {
	// Skip file generation for JSON-only structs (they're generated as paths in their parent)
	if meta.IsJSONOnly {
		return nil
	}

	// Populate dynamic fields
	meta.GeneratedAt = time.Now().Format(time.RFC3339)
	for _, f := range meta.Fields {
		if strings.Contains(meta.GetFieldType(f.Type), "field.JSON") {
			meta.HasJSON = true
		}
		// Parse JSON field paths if type:json is set
		if f.IsJSON && f.JSONTypeName != "" {
			meta.HasJSONField = true
			paths := parseJSONStructPaths(outDir, f.JSONTypeName, "")
			if len(paths) > 0 {
				meta.JSONFields = append(meta.JSONFields, JSONFieldMeta{
					FieldName:  f.FieldName,
					TypeName:   f.JSONTypeName,
					ColumnName: f.Column,
					Paths:      paths,
				})
			}
		}
	}

	tmpl, err := template.New("schema").Parse(schemaTemplate)
	if err != nil {
		return err
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, meta); err != nil {
		return err
	}

	// Create generated subdirectory
	generatedDir := filepath.Join(outDir, "generated")
	if err := os.MkdirAll(generatedDir, 0755); err != nil {
		return err
	}

	filename := filepath.Join(generatedDir, strings.ToLower(meta.ModelName)+"_gen.go")
	return os.WriteFile(filename, buf.Bytes(), 0644)
}

// GetFieldType returns the appropriate field type based on Go type
func (m ModelMeta) GetFieldType(goType string) string {
	// 1. Check user-defined mapping first (from config.go)
	if m.FieldTypeMap != nil {
		if fieldType, ok := m.FieldTypeMap[goType]; ok {
			return fieldType
		}
	}

	// 2. Resolve type aliases (type A int â†’ int)
	resolvedType := goType
	isAlias := false
	if m.TypeAliases != nil {
		if underlying, ok := m.TypeAliases[goType]; ok {
			resolvedType = underlying
			isAlias = true
		}
	}

	// 3. For numeric aliases, use the alias type in generic (field.Number[Alias])
	if isAlias {
		// Qualify type if it's from current package
		typeName := goType
		if !strings.Contains(goType, ".") && m.ParentPackage != "" {
			typeName = m.ParentPackage + "." + goType
		}

		if m.IsNumeric(resolvedType) {
			return fmt.Sprintf("field.Number[%s]", typeName)
		}

		// For non-numeric aliases (e.g. String alias), use generic Field[T]
		// This supports custom types without dedicated field implementation
		return fmt.Sprintf("field.Field[%s]", typeName)
	}

	// 4. Map to field types
	fieldType := m.mapToFieldType(resolvedType)

	// 5. If mapToFieldType returns basic "field.Field[any]", upgrade to generic "field.Field[T]" if possible
	if fieldType == "field.Field[any]" {
		// Check if it's a struct or something we can use generic Field for?
		// For now, let's assume unknown types are better off as field.Field[Type] if they are not standard.
		// But mapToFieldType has default case.

		// If goType is simply "MyStruct", we want "field.Field[MyStruct]" (qualified).
		if !m.isBuiltin(goType) {
			typeName := goType
			if !strings.Contains(goType, ".") && m.ParentPackage != "" {
				typeName = m.ParentPackage + "." + goType
			}
			return fmt.Sprintf("field.Field[%s]", typeName)
		}
	}

	return fieldType
}

func (m ModelMeta) isBuiltin(typ string) bool {
	switch typ {
	case "string", "int", "int64", "float64", "bool", "byte", "rune", "any", "complex64", "complex128", "error":
		return true
	}
	return false
}

// mapToFieldType converts a Go type to its corresponding field type
func (m ModelMeta) mapToFieldType(goType string) string {
	switch goType {
	case "string":
		return "field.String"
	case "int":
		return "field.Number[int]"
	case "int8":
		return "field.Number[int8]"
	case "int16":
		return "field.Number[int16]"
	case "int32":
		return "field.Number[int32]"
	case "int64":
		return "field.Number[int64]"
	case "uint":
		return "field.Number[uint]"
	case "uint8":
		return "field.Number[uint8]"
	case "uint16":
		return "field.Number[uint16]"
	case "uint32":
		return "field.Number[uint32]"
	case "uint64":
		return "field.Number[uint64]"
	case "float32":
		return "field.Number[float32]"
	case "float64":
		return "field.Number[float64]"
	case "bool":
		return "field.Bool"
	case "time.Time", "*time.Time":
		return "field.Time"
	case "[]byte":
		return "field.Bytes"
	case "json.RawMessage":
		return "field.JSON[json.RawMessage]"
	default:
		return "field.Field[any]"
	}
}

// IsNumeric checks if the Go type is numeric
func (m ModelMeta) IsNumeric(goType string) bool {
	switch goType {
	case "int", "int8", "int16", "int32", "int64",
		"uint", "uint8", "uint16", "uint32", "uint64",
		"float32", "float64":
		return true
	default:
		// Check aliases
		if m.TypeAliases != nil {
			if underlying, ok := m.TypeAliases[goType]; ok {
				return m.IsNumeric(underlying)
			}
		}
		return false
	}
}

// QualifyPKType returns the qualified type name for the PK field
func (m ModelMeta) QualifyPKType() string {
	typ := m.PKFieldType
	// If it's a built-in numeric type, no qualification needed.
	switch typ {
	case "int", "int8", "int16", "int32", "int64",
		"uint", "uint8", "uint16", "uint32", "uint64",
		"float32", "float64":
		return typ
	}
	// If it's an alias, qualify it.
	if !strings.Contains(typ, ".") && m.ParentPackage != "" {
		return m.ParentPackage + "." + typ
	}
	return typ
}

// GoIsNonZero returns the Go expression to check if a field is NOT zero value
func (m ModelMeta) GoIsNonZero(fieldName, goType string) string {
	if strings.HasPrefix(goType, "*") || strings.HasPrefix(goType, "[]") || strings.HasPrefix(goType, "map") {
		return "m." + fieldName + " != nil"
	}
	switch goType {
	case "string":
		return "m." + fieldName + " != \"\""
	case "int", "int8", "int16", "int32", "int64",
		"uint", "uint8", "uint16", "uint32", "uint64",
		"float32", "float64":
		return "m." + fieldName + " != 0"
	case "bool":
		return "m." + fieldName // bool zero is false, so non-zero is true
	case "time.Time":
		return "!m." + fieldName + ".IsZero()"
	case "json.RawMessage":
		return "len(m." + fieldName + ") > 0"
	default:
		// Slices, structs etc.
		if strings.HasPrefix(goType, "[]") {
			return "len(m." + fieldName + ") > 0"
		}
		// For structs, use strict IsZero check inverted
		return fmt.Sprintf("!reflect.ValueOf(m.%s).IsZero()", fieldName)
	}
}
