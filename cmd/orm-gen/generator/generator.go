package generator

import (
	"bytes"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"text/template"
	"time"
)

const schemaTemplate = `// Code generated by orm-gen. DO NOT EDIT.
// Generated at: {{.GeneratedAt}}

package {{.PackageName}}

import (
	"github.com/arllen133/sqlc"
	"github.com/arllen133/sqlc/clause"
	"github.com/arllen133/sqlc/field"
	{{if .PackagePath}}"{{.ModulePath}}/{{.PackagePath}}"{{end}}
	{{if .HasJSON}}"encoding/json"{{end}}
)

// {{.ModelName}} Schema:
{{- range .Doc}}
// {{.}}
{{- end}}
type {{.SchemaStructName}} struct {
	{{- range .Fields}}
	{{- if .Doc}}
	// {{.FieldName}}: {{range .Doc}}{{.}}{{end}}
	{{- end}}
	{{.FieldName}} {{$.GetFieldType .Type}}
	{{- end}}
}

var _ sqlc.Schema[{{.ParentPackage}}.{{.ModelName}}] = (*{{.SchemaStructName}})(nil)

var {{.ModelName}} = {{.SchemaStructName}}{
	{{- range .Fields}}
	{{.FieldName}}: {{$.GetFieldType .Type}}{}.WithColumn("{{.Column}}"),
	{{- end}}
}

func (s *{{.SchemaStructName}}) TableName() string {
	return "{{.TableName}}"
}

func (s *{{.SchemaStructName}}) SelectColumns() []string {
	return []string{
		{{- range .Fields}}
		"{{.Column}}",
		{{- end}}
	}
}

func (s *{{.SchemaStructName}}) InsertRow(m *{{.ParentPackage}}.{{.ModelName}}) ([]string, []any) {
	var cols []string
	var vals []any
	{{- range .Fields}}
	{{- if .IsPK}}
	{{- if $.IsAutoIncrementPK}}
	// AutoIncrement PK: include only if explicitly set (non-zero)
	if m.{{.FieldName}} != 0 {
		cols = append(cols, "{{.Column}}")
		vals = append(vals, m.{{.FieldName}})
	}
	{{- else}}
	// Non-AutoIncrement PK: always include
	cols = append(cols, "{{.Column}}")
	vals = append(vals, m.{{.FieldName}})
	{{- end}}
	{{- else}}
	cols = append(cols, "{{.Column}}")
	vals = append(vals, m.{{.FieldName}})
	{{- end}}
	{{- end}}
	return cols, vals
}

func (s *{{.SchemaStructName}}) UpdateMap(m *{{.ParentPackage}}.{{.ModelName}}) map[string]any {
	res := make(map[string]any)
	{{- range .Fields}}
	{{- if not .IsPK}}
	res["{{.Column}}"] = m.{{.FieldName}}
	{{- end}}
	{{- end}}
	return res
}

func (s *{{.SchemaStructName}}) PK(m *{{.ParentPackage}}.{{.ModelName}}) sqlc.PK {
	{{- if .PKFieldName}}
	var val any
	if m != nil {
		val = m.{{.PKFieldName}}
	}
	return sqlc.PK{
		Column: clause.Column{Name: "{{.PKColumnName}}"},
		Value:  val,
	}
	{{- else}}
	return sqlc.PK{}
	{{- end}}
}

func (s *{{.SchemaStructName}}) SetPK(m *{{.ParentPackage}}.{{.ModelName}}, val int64) {
	{{- if .PKFieldName}}
	{{- if eq .PKFieldType "int64"}}
	m.{{.PKFieldName}} = val
	{{- else if $.IsNumeric .PKFieldType}}
	m.{{.PKFieldName}} = {{.PKFieldType}}(val)
	{{- end}}
	{{- end}}
}

func (s *{{.SchemaStructName}}) AutoIncrement() bool {
	return {{.IsAutoIncrementPK}}
}

func init(){
	sqlc.RegisterSchema(&{{.ModelName}})
}
`

func GenerateFile(meta ModelMeta, outDir string) error {
	// Populate dynamic fields
	meta.GeneratedAt = time.Now().Format(time.RFC3339)
	for _, f := range meta.Fields {
		if strings.Contains(meta.GetFieldType(f.Type), "field.JSON") {
			meta.HasJSON = true
			break
		}
	}

	tmpl, err := template.New("schema").Parse(schemaTemplate)
	if err != nil {
		return err
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, meta); err != nil {
		return err
	}

	// Create generated subdirectory
	generatedDir := filepath.Join(outDir, "generated")
	if err := os.MkdirAll(generatedDir, 0755); err != nil {
		return err
	}

	filename := filepath.Join(generatedDir, strings.ToLower(meta.ModelName)+"_gen.go")
	return os.WriteFile(filename, buf.Bytes(), 0644)
}

// GetFieldType returns the appropriate field type based on Go type
func (m ModelMeta) GetFieldType(goType string) string {
	switch goType {
	case "string":
		return "field.String"
	case "int":
		return "field.Number[int]"
	case "int8":
		return "field.Number[int8]"
	case "int16":
		return "field.Number[int16]"
	case "int32":
		return "field.Number[int32]"
	case "int64":
		return "field.Number[int64]"
	case "uint":
		return "field.Number[uint]"
	case "uint8":
		return "field.Number[uint8]"
	case "uint16":
		return "field.Number[uint16]"
	case "uint32":
		return "field.Number[uint32]"
	case "uint64":
		return "field.Number[uint64]"
	case "float32":
		return "field.Number[float32]"
	case "float64":
		return "field.Number[float64]"
	case "bool":
		return "field.Bool"
	case "time.Time", "*time.Time":
		return "field.Time"
	case "[]byte":
		return "field.Bytes"
	case "json.RawMessage":
		return "field.JSON[json.RawMessage]"
	default:
		// Fallback for custom JSON types?
		// Check if it looks like a struct or complex type we might treat as JSON?
		// For now simple default.
		return "field.Field"
	}
}

// IsNumeric checks if the Go type is numeric
func (m ModelMeta) IsNumeric(goType string) bool {
	switch goType {
	case "int", "int8", "int16", "int32", "int64",
		"uint", "uint8", "uint16", "uint32", "uint64",
		"float32", "float64":
		return true
	default:
		return false
	}
}

// GoIsNonZero returns the Go expression to check if a field is NOT zero value
func (m ModelMeta) GoIsNonZero(fieldName, goType string) string {
	if strings.HasPrefix(goType, "*") || strings.HasPrefix(goType, "[]") || strings.HasPrefix(goType, "map") {
		return "m." + fieldName + " != nil"
	}
	switch goType {
	case "string":
		return "m." + fieldName + " != \"\""
	case "int", "int8", "int16", "int32", "int64",
		"uint", "uint8", "uint16", "uint32", "uint64",
		"float32", "float64":
		return "m." + fieldName + " != 0"
	case "bool":
		return "m." + fieldName // bool zero is false, so non-zero is true
	case "time.Time":
		return "!m." + fieldName + ".IsZero()"
	case "json.RawMessage":
		return "len(m." + fieldName + ") > 0"
	default:
		// Slices, structs etc.
		if strings.HasPrefix(goType, "[]") {
			return "len(m." + fieldName + ") > 0"
		}
		// For structs, use strict IsZero check inverted
		return fmt.Sprintf("!reflect.ValueOf(m.%s).IsZero()", fieldName)
	}
}
