// Package sqlc provides a type-safe ORM library using generics and code generation.
// This file implements the model-to-database table mapping mechanism, which is the core abstraction of sqlc ORM.
//
// The Schema interface defines how to map Go structs to database tables, including:
//   - Table name mapping
//   - Column selection
//   - Insert data extraction
//   - Update data mapping
//   - Primary key management
//   - Soft delete support
package sqlc

import (
	"fmt"
	"reflect"

	"github.com/arllen133/sqlc/clause"
)

// PK is a type alias for primary key equality expression.
// Used to simplify primary key query writing.
//
// Example:
//
//	pk := schema.PK(model) // Get primary key condition
//	query.Where(pk)        // Use primary key as query condition
type PK = clause.Eq

// Schema defines how to map model T to a database table and back.
// This is the core interface of sqlc ORM, all models need to implement this interface.
//
// This interface is usually automatically implemented by the code generator, developers don't need to write it manually.
// The code generator parses model struct tags (e.g., `db:"column_name"`) and generates the implementation.
//
// Types implementing this interface must provide the following functionality:
//   - Table metadata (table name)
//   - Read operations (which columns to select)
//   - Write operations (how to insert and update)
//   - Primary key management (how to get and set primary key)
//
// Usage example (generated by code generator):
//
//	type UserSchema struct{}
//
//	func (s UserSchema) TableName() string {
//	    return "users"
//	}
//
//	func (s UserSchema) SelectColumns() []string {
//	    return []string{"id", "email", "name", "created_at"}
//	}
//
//	func (s UserSchema) InsertRow(user *User) ([]string, []any) {
//	    return []string{"email", "name"},
//	           []any{user.Email, user.Name}
//	}
//
//	func (s UserSchema) UpdateMap(user *User) map[string]any {
//	    return map[string]any{
//	        "email": user.Email,
//	        "name":  user.Name,
//	    }
//	}
//
//	func (s UserSchema) PK(user *User) PK {
//	    return clause.Eq{
//	        Column: clause.Column{Name: "id"},
//	        Value:  user.ID,
//	    }
//	}
//
//	func (s UserSchema) SetPK(user *User, val int64) {
//	    user.ID = val
//	}
//
//	func (s UserSchema) AutoIncrement() bool {
//	    return true
//	}
type Schema[T any] interface {
	// TableName returns the database table name for the model.
	//
	// Returns:
	//   - string: Table name (e.g., "users", "orders")
	//
	// Example:
	//   func (s UserSchema) TableName() string { return "users" }
	TableName() string

	// SelectColumns returns the list of column names to select in queries.
	// These columns will be used in SELECT statements and result scanning.
	//
	// Returns:
	//   - []string: List of column names (e.g., ["id", "email", "name"])
	//
	// Note:
	//   - Column names should match database column names
	//   - Column names should match model's db tags
	//   - Usually doesn't include auto-timestamp columns like created_at, updated_at
	//
	// Example:
	//   func (s UserSchema) SelectColumns() []string {
	//       return []string{"id", "email", "name", "age"}
	//   }
	SelectColumns() []string

	// InsertRow extracts insert data from a model instance.
	// Used in Create() and BatchCreate() operations.
	//
	// Parameters:
	//   - *T: Model instance pointer
	//
	// Returns:
	//   - []string: List of column names to insert
	//   - []any: List of corresponding column values
	//
	// Note:
	//   - Usually doesn't include auto-increment primary key column
	//   - Can include default values or computed fields
	//   - Column and value order must match
	//
	// Example:
	//   func (s UserSchema) InsertRow(user *User) ([]string, []any) {
	//       return []string{"email", "name", "age"},
	//              []any{user.Email, user.Name, user.Age}
	//   }
	InsertRow(*T) ([]string, []any)

	// UpdateMap generates update mapping from a model instance.
	// Used in Update() operations.
	//
	// Parameters:
	//   - *T: Model instance pointer
	//
	// Returns:
	//   - map[string]any: Mapping from column names to new values
	//
	// Note:
	//   - Usually doesn't include primary key column
	//   - Can include auto-update fields like updated_at
	//   - Empty map results in UPDATE with no actual changes
	//
	// Example:
	//   func (s UserSchema) UpdateMap(user *User) map[string]any {
	//       return map[string]any{
	//           "email": user.Email,
	//           "name":  user.Name,
	//           "age":   user.Age,
	//       }
	//   }
	UpdateMap(*T) map[string]any

	// PK extracts primary key information from a model instance.
	// Used to build primary key query conditions.
	//
	// Parameters:
	//   - *T: Model instance pointer (can be nil, only used to get column info)
	//
	// Returns:
	//   - PK: Primary key equality expression (containing column name and value)
	//
	// Note:
	//   - When parameter is nil, returned PK should contain correct column info, but value can be zero
	//   - Used for operations like First(), Last() that need primary key column info
	//
	// Example:
	//   func (s UserSchema) PK(user *User) PK {
	//       if user == nil {
	//           return clause.Eq{Column: clause.Column{Name: "id"}}
	//       }
	//       return clause.Eq{
	//           Column: clause.Column{Name: "id"},
	//           Value:  user.ID,
	//       }
	//   }
	PK(*T) PK

	// SetPK sets the primary key value on a model instance.
	// Used to backfill ID after insert for auto-increment primary keys.
	//
	// Parameters:
	//   - m: Model instance pointer
	//   - val: Primary key value (auto-increment ID returned from database)
	//
	// Example:
	//   func (s UserSchema) SetPK(user *User, val int64) {
	//       user.ID = val
	//   }
	SetPK(m *T, val int64)

	// AutoIncrement indicates whether the table uses auto-increment primary key.
	//
	// Returns:
	//   - bool: true means auto-increment primary key, false means manual assignment
	//
	// Behavior:
	//   - true: Create() will call SetPK() to backfill ID
	//   - false: Create() won't attempt to get and set ID
	//
	// Example:
	//   func (s UserSchema) AutoIncrement() bool { return true }
	AutoIncrement() bool

	// SoftDeleteColumn returns the soft delete column name.
	// Returns "" if the model does not support soft delete.
	SoftDeleteColumn() string

	// SoftDeleteValue returns the value to set on the soft delete column when deleting.
	// For *time.Time -> time.Now(), for int64 -> time.Now().Unix(), etc.
	// Returns nil if soft delete is not supported.
	SoftDeleteValue() any

	// SetDeletedAt sets the deletion marker on the model instance.
	// No-op if soft delete is not supported.
	SetDeletedAt(m *T)
}

// schemas is the global Schema registry.
// Uses reflect.Type as key to support any model type.
// Thread safety: All registrations should be completed during program initialization, after which it's read-only.
var schemas = make(map[reflect.Type]any)

// RegisterSchema registers a Schema implementation for a model.
// Usually called during program initialization (e.g., in init() functions).
//
// Parameters:
//   - schema: Schema implementation for the model
//
// Type parameter:
//   - T: Model type
//
// Note:
//   - Each type can only be registered once, duplicate registrations will overwrite
//   - All registrations should be completed at program startup
//   - After registration, can be retrieved via LoadSchema[T]()
//
// Example:
//
//	func init() {
//	    sqlc.RegisterSchema[models.User](generated.UserSchema{})
//	    sqlc.RegisterSchema[models.Order](generated.OrderSchema{})
//	}
func RegisterSchema[T any](schema Schema[T]) {
	var t T
	typ := reflect.TypeOf(t)
	schemas[typ] = schema
}

// LoadSchema loads the registered Schema for a model.
// Panics if the type is not registered.
//
// Type parameter:
//   - T: Model type
//
// Returns:
//   - Schema[T]: Schema implementation for the model
//
// Panics:
//   - panic: If type is not registered
//
// Usage scenarios:
//   - Repository initialization
//   - Query building
//   - Relation loading
//
// Example:
//
//	schema := sqlc.LoadSchema[models.User]()
//	tableName := schema.TableName()
func LoadSchema[T any]() Schema[T] {
	var t T
	typ := reflect.TypeOf(t)
	if s, ok := schemas[typ]; ok {
		return s.(Schema[T])
	}
	// Provide clear error message when not registered
	panic(fmt.Sprintf("sqlc: schema not registered for type %v", typ))
}

// ScanRows was removed as part of sqlx refactor.
// Now directly use sqlx's SelectContext and GetContext methods.
